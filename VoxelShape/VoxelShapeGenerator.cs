using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace GraffitiEntertainment.VoxelShape
{
    public static class VoxelShapeGenerator
    {
        public enum ShapeType
        {
            Cube,
            Sphere,
            Wedge,
            FromImage
        }

        public static List<Vector3> GenerateShape(ShapeType type, Vector3 shapeSize, Vector3 gridSize,
            Vector3 rotation = default, Texture2D image = null, string spriteName = null, Rect spriteRect = default)
        {
            switch (type)
            {
                case ShapeType.Cube:
                    return GenerateCube(shapeSize, gridSize, rotation);
                case ShapeType.Sphere:
                    return GenerateSphere(shapeSize, gridSize);
                case ShapeType.Wedge:
                    return GenerateWedge(shapeSize, gridSize, rotation);
                case ShapeType.FromImage:
                    return GenerateFromImage(shapeSize, gridSize, rotation, image, spriteName, spriteRect);
                default:
                    return new List<Vector3>();
            }
        }

        public static List<Vector3> SubtractVoxelCells(List<Vector3> baseCells, List<Vector3> subtractCells,
            Vector3 offset)
        {
            // Create a HashSet of the cells to subtract for efficient lookup.
            // Apply the offset *before* adding to the HashSet.
            HashSet<Vector3> cellsToSubtract = new HashSet<Vector3>(subtractCells.Select(cell => cell + offset));

            // Use LINQ's Where to filter out cells present in the subtraction set.
            // This performs an exact comparison efficiently thanks to HashSet.
            List<Vector3> result = baseCells.Where(cell => !cellsToSubtract.Contains(cell)).ToList();

            return result;
        }

        public static List<Vector3> AddVoxelCells(List<Vector3> baseCells, List<Vector3> addCells, Vector3 offset)
        {
            // Use a HashSet to store the base cells for efficient checking of duplicates.
            HashSet<Vector3> resultSet = new HashSet<Vector3>(baseCells);

            // Iterate through the cells to add.
            foreach (var addCell in addCells)
            {
                // Apply the offset to the cell position.
                Vector3 adjustedPos = addCell + offset;

                // Add the adjusted position to the HashSet.
                // HashSet automatically handles duplicates (won't add if already present).
                resultSet.Add(adjustedPos);
            }

            // Convert the HashSet back to a List for the return value.
            return resultSet.ToList();
        }

        private static List<Vector3> GenerateCube(Vector3 shapeSize, Vector3 gridSize, Vector3 rotation)
        {
            var cells = new List<Vector3>();
            if (gridSize.x <= 0 || gridSize.y <= 0 || gridSize.z <= 0) { /* Error */ return cells; }
            shapeSize = new Vector3(Mathf.Max(0, shapeSize.x), Mathf.Max(0, shapeSize.y), Mathf.Max(0, shapeSize.z));
            Vector3 halfShapeSize = shapeSize / 2.0f;

            Quaternion rot = Quaternion.Euler(rotation);
            Quaternion inverseRot = Quaternion.Inverse(rot);

            // Iterate using the target voxel counts centered around origin
            foreach (int x_idx in GetCenteredIndexRange(shapeSize.x, gridSize.x))
            {
                foreach (int y_idx in GetCenteredIndexRange(shapeSize.y, gridSize.y))
                {
                    foreach (int z_idx in GetCenteredIndexRange(shapeSize.z, gridSize.z))
                    {
                        // Calculate the center position of this potential voxel
                        Vector3 voxelCenterPos = new Vector3(x_idx * gridSize.x, y_idx * gridSize.y, z_idx * gridSize.z);

                        // --- Still perform bounds check for rotated cases ---
                        // This ensures voxels generated by the index loop aren't clipped
                        // if rotation pushes their center outside the intended bounding box.
                        Vector3 rotatedCheckPos = inverseRot * voxelCenterPos;

                        bool isInBounds =
                            Mathf.Abs(rotatedCheckPos.x) <= halfShapeSize.x + Mathf.Epsilon &&
                            Mathf.Abs(rotatedCheckPos.y) <= halfShapeSize.y + Mathf.Epsilon &&
                            Mathf.Abs(rotatedCheckPos.z) <= halfShapeSize.z + Mathf.Epsilon;

                        if (isInBounds)
                        {
                            cells.Add(voxelCenterPos);
                        }
                    }
                }
            }
            return cells;
        }

        private static List<Vector3> GenerateSphere(Vector3 shapeSize, Vector3 gridSize)
        {
            var cells = new List<Vector3>();
            if (gridSize.x <= 0 || gridSize.y <= 0 || gridSize.z <= 0) { /* Error */ return cells; }
            shapeSize = new Vector3(Mathf.Max(0, shapeSize.x), Mathf.Max(0, shapeSize.y), Mathf.Max(0, shapeSize.z));
            Vector3 radii = shapeSize / 2.0f;
            if (radii.x <= 0 || radii.y <= 0 || radii.z <= 0) return cells;

            // Iterate using the target voxel counts centered around origin
            foreach (int x_idx in GetCenteredIndexRange(shapeSize.x, gridSize.x))
            {
                foreach (int y_idx in GetCenteredIndexRange(shapeSize.y, gridSize.y))
                {
                    foreach (int z_idx in GetCenteredIndexRange(shapeSize.z, gridSize.z))
                    {
                        Vector3 voxelCenterPos = new Vector3(x_idx * gridSize.x, y_idx * gridSize.y, z_idx * gridSize.z);

                        // Check if the voxel center is within the ellipsoid equation
                        float checkX = (radii.x == 0) ? 0 : voxelCenterPos.x / radii.x; // Avoid division by zero
                        float checkY = (radii.y == 0) ? 0 : voxelCenterPos.y / radii.y;
                        float checkZ = (radii.z == 0) ? 0 : voxelCenterPos.z / radii.z;

                        if ((checkX * checkX + checkY * checkY + checkZ * checkZ) <= 1.0f + Mathf.Epsilon)
                        {
                            cells.Add(voxelCenterPos);
                        }
                    }
                }
            }
            return cells;
        }
        
        private static List<Vector3> GenerateWedge(Vector3 shapeSize, Vector3 gridSize, Vector3 rotation)
        {
            var cells = new List<Vector3>();
            if (gridSize.x <= 0 || gridSize.y <= 0 || gridSize.z <= 0) { /* Error */ return cells; }
            shapeSize = new Vector3(Mathf.Max(0, shapeSize.x), Mathf.Max(0, shapeSize.y), Mathf.Max(0, shapeSize.z));
            Vector3 halfShapeSize = shapeSize / 2.0f;
            if (halfShapeSize.y <= 0) return cells;

            Quaternion rot = Quaternion.Euler(rotation);
            Quaternion inverseRot = Quaternion.Inverse(rot);

            // Iterate using the target voxel counts centered around origin
            foreach (int x_idx in GetCenteredIndexRange(shapeSize.x, gridSize.x))
            {
                foreach (int y_idx in GetCenteredIndexRange(shapeSize.y, gridSize.y))
                {
                    foreach (int z_idx in GetCenteredIndexRange(shapeSize.z, gridSize.z))
                    {
                        Vector3 voxelCenterPos = new Vector3(x_idx * gridSize.x, y_idx * gridSize.y, z_idx * gridSize.z);
                        Vector3 rotatedCheckPos = inverseRot * voxelCenterPos;

                        // Check height first
                        if (Mathf.Abs(rotatedCheckPos.y) <= halfShapeSize.y + Mathf.Epsilon)
                        {
                            float heightFraction = (halfShapeSize.y == 0) ? 0 : Mathf.Abs(rotatedCheckPos.y) / halfShapeSize.y;
                            float xLimit = Mathf.Lerp(halfShapeSize.x, 0, heightFraction);
                            float zLimit = Mathf.Lerp(halfShapeSize.z, 0, heightFraction);

                            bool isInBounds =
                                Mathf.Abs(rotatedCheckPos.x) <= xLimit + Mathf.Epsilon &&
                                Mathf.Abs(rotatedCheckPos.z) <= zLimit + Mathf.Epsilon;

                            if (isInBounds)
                            {
                                cells.Add(voxelCenterPos);
                            }
                        }
                    }
                }
            }
            return cells;
        }
        
        private static List<Vector3> GenerateFromImage(Vector3 shapeSize, Vector3 gridSize, Vector3 rotation,
            Texture2D image, string spriteName, Rect spriteRect)
        {
            var cells = new List<Vector3>();
            if (image == null)
            {
                return cells;
            }

            if (gridSize.x <= 0 || gridSize.y <= 0 || gridSize.z <= 0)
            {
                /* Error */
                return cells;
            }

            // Ensure shape size is non-negative, but allow it to influence gridCount
            Vector3 nonNegativeShapeSize = new Vector3(Mathf.Max(0, shapeSize.x), Mathf.Max(0, shapeSize.y),
                Mathf.Max(0, shapeSize.z));


            // Determine the target grid dimensions based on shapeSize
            Vector3Int gridCount = Vector3Int.CeilToInt(new Vector3(
                nonNegativeShapeSize.x / gridSize.x,
                nonNegativeShapeSize.y / gridSize.y,
                nonNegativeShapeSize.z / gridSize.z
            ));

            if (gridCount.x <= 0 || gridCount.y <= 0 || gridCount.z <= 0)
            {
                return cells; // No voxels to generate
            }

            // --- REVISED CENTERING ---
            // Center the block of generated voxels around the local origin (0,0,0)
            Vector3 totalGridVolumeSize = Vector3.Scale(gridCount, gridSize);
            Vector3 centerOffset = (totalGridVolumeSize - gridSize) / 2.0f;
            // --- END REVISED CENTERING ---


            // --- Sprite Rect / Sampling Logic (remains mostly the same) ---
            Rect samplingRect = spriteRect;
            if (!string.IsNullOrEmpty(spriteName) && spriteRect != Rect.zero && spriteRect.width > 0 &&
                spriteRect.height > 0)
            {
                // Use provided rect if valid
            }
            else
            {
                // Fallback to full image if no valid sprite/rect provided
                samplingRect = new Rect(0, 0, image.width, image.height);
            }

            // Clamp samplingRect to texture bounds (important!)
            samplingRect.x = Mathf.Clamp(samplingRect.x, 0, image.width);
            samplingRect.y = Mathf.Clamp(samplingRect.y, 0, image.height);
            samplingRect.width = Mathf.Clamp(samplingRect.width, 0, image.width - samplingRect.x);
            samplingRect.height = Mathf.Clamp(samplingRect.height, 0, image.height - samplingRect.y);
            if (samplingRect.width <= 0 || samplingRect.height <= 0) return cells; // Cannot sample zero area

            float pixelsPerGridX = samplingRect.width / gridCount.x;
            float pixelsPerGridZ = samplingRect.height / gridCount.z; // Note: Image maps to XZ plane

            // Sampling rate and threshold (adjust baseThreshold as needed)
            float samplingRateX = Mathf.Max(1f, pixelsPerGridX);
            float samplingRateZ = Mathf.Max(1f, pixelsPerGridZ);
            float maxSamplingRate = Mathf.Max(samplingRateX, samplingRateZ);
            float baseThreshold = 0.5f;
            // Consider if threshold needs adjustment for sampling rate, maybe inverse relationship?
            // float threshold = baseThreshold / maxSamplingRate; // This might be too aggressive
            float threshold = baseThreshold; // Start simple

            Quaternion rot = Quaternion.Euler(rotation);

            // Loop through the destination grid cells
            for (int x = 0; x < gridCount.x; x++)
            {
                for (int z = 0; z < gridCount.z; z++) // Image maps to XZ plane
                {
                    // --- Image Sampling Logic (remains the same) ---
                    float grayscaleValue;
                    // Map destination grid cell (x, z) to source texture UV within samplingRect
                    float u = (gridCount.x <= 1) ? 0.5f : (float)x / (gridCount.x - 1); // Normalize x to [0, 1]
                    float v = (gridCount.z <= 1) ? 0.5f : (float)z / (gridCount.z - 1); // Normalize z to [0, 1]
                    // Map to pixel coordinates within samplingRect
                    float pixelX = samplingRect.x + u * samplingRect.width;
                    float pixelY = samplingRect.y + v * samplingRect.height; // Texture Y maps to world Z

                    // Choose sampling method based on pixelsPerGrid
                    if (Mathf.Approximately(pixelsPerGridX, 1f) && Mathf.Approximately(pixelsPerGridZ, 1f))
                    {
                        // 1:1 mapping - Sample center pixel
                        int sampleX = Mathf.Clamp(Mathf.FloorToInt(pixelX), 0, image.width - 1);
                        int sampleY = Mathf.Clamp(Mathf.FloorToInt(pixelY), 0, image.height - 1);
                        grayscaleValue = image.GetPixel(sampleX, sampleY).grayscale;
                    }
                    else if (pixelsPerGridX < 1f || pixelsPerGridZ < 1f)
                    {
                        // Upscaling - Sample nearest pixel
                        int sampleX = Mathf.Clamp(Mathf.FloorToInt(pixelX), 0, image.width - 1);
                        int sampleY = Mathf.Clamp(Mathf.FloorToInt(pixelY), 0, image.height - 1);
                        grayscaleValue = image.GetPixel(sampleX, sampleY).grayscale;
                    }
                    else
                    {
                        // Downscaling - Use bilinear sampling over the area
                        // More robust: Average GetPixelBilinear samples within the target pixel area
                        float avgGrayscale = 0;
                        int samples = 0;
                        // Example: 4 samples within the pixel block this grid cell represents
                        for (float subU = 0.25f; subU < 1.0f; subU += 0.5f)
                        {
                            for (float subV = 0.25f; subV < 1.0f; subV += 0.5f)
                            {
                                float currentPixelX = samplingRect.x + (x + subU) * pixelsPerGridX;
                                float currentPixelY = samplingRect.y + (z + subV) * pixelsPerGridZ;
                                // Convert to texture UV (0-1 range for whole texture)
                                float textureU = Mathf.Clamp01(currentPixelX / image.width);
                                float textureV = Mathf.Clamp01(currentPixelY / image.height);
                                avgGrayscale += image.GetPixelBilinear(textureU, textureV).grayscale;
                                samples++;
                            }
                        }

                        grayscaleValue = (samples > 0) ? avgGrayscale / samples : 0;
                    }
                    // --- End Image Sampling Logic ---


                    // Determine if voxel should be placed based on threshold
                    bool isOpaque = grayscaleValue > threshold;

                    if (isOpaque)
                    {
                        // Generate voxels for the full height (gridCount.y) at this XZ position
                        for (int y = 0; y < gridCount.y; y++)
                        {
                            // Calculate position relative to the corner, apply centering offset, then rotate
                            Vector3 cornerRelativePos = new Vector3(x * gridSize.x, y * gridSize.y, z * gridSize.z);
                            Vector3 pos = cornerRelativePos - centerOffset; // Apply centering
                            Vector3 rotatedPos = rot * pos; // Apply rotation
                            cells.Add(rotatedPos);
                        }
                    }
                }
            }

            return cells;
        }
        
        private static IEnumerable<int> GetCenteredIndexRange(float shapeSizeAxis, float gridSizeAxis)
        {
            if (gridSizeAxis <= 0) yield break; // Avoid division by zero

            int targetVoxelCount = Mathf.RoundToInt(shapeSizeAxis / gridSizeAxis);

            if (targetVoxelCount <= 0) yield break; // No voxels to generate

            if (targetVoxelCount % 2 != 0)
            {
                // Odd count: e.g., N=5 -> indices -2, -1, 0, 1, 2
                int halfRange = (targetVoxelCount - 1) / 2;
                for (int i = -halfRange; i <= halfRange; i++)
                {
                    yield return i;
                }
            }
            else
            {
                // Even count: e.g., N=4 -> indices -2, -1, 0, 1 (centered around -0.5)
                // Or choose: indices -1, 0, 1, 2 (centered around +0.5)
                // Let's use the range centered around -0.5 for consistency: -N/2 to N/2 - 1
                int halfRange = targetVoxelCount / 2;
                for (int i = -halfRange; i < halfRange; i++) // Note: i < halfRange (exclusive end)
                {
                    yield return i;
                }
            }
        }
    }
}


